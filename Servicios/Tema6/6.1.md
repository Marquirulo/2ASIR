# TEMA 6. SERVICIOS WEB: APACHE

# 6.1:
EL PROTOCOLO HTTP: EL CLIENTE  
Vamos a ver el lado del cliente, para eso nos pasamos por un servidor y vemos lo que envía el cliente para solicitar la página web.  
EN “DEBIAN SERVIDOR”, COMO root, LANZAR “nc”  
Lo lanzamos con “nc -lp 80”: l para que escuche y p para especificar el puerto:  
EN “UBUNTU”, ESCRIBIMOS LA CONEXIÓN A “DEBIAN  SERVIDOR” EN EL NAVEGADOR DE INTERNET.  

Escribimos en la barra de direcciones del navegador web la solicitud http con una petición de recurso: http://10.131.72.1/pagina.html


EN “DEBIAN SERVIDOR”, COMPROBAR QUE EN “nc” HA  APARECIDO LA SOLICITUD http

![imagen](https://github.com/user-attachments/assets/fd52fc80-a278-44f7-929e-b70c733950f5)

EN “DEBIAN SERVIDOR”, CONTESTAR ENVIANDO UNA  PÁGINA WEB COMO RESPUESTA

![imagen](https://github.com/user-attachments/assets/b40c1bee-4735-4715-a82f-c597fa3ddd2c)

AL TERMINAR LA PÁGINA, PULSAR Ctrl+c PARA  DESCONECTAR

EN “UBUNTU”, COMPROBAR QUE HA APARECIDO LA PÁGINA


Entramos en la configuración del navegador:

# 6.2

[AÑADIR UNA CADENA CON EL VALOR DE OTRO NAVEGADOR  
➔ Nos colocamos encima de cualquier valor y con el botón derecho elegimos  
nuevo, cadena y escribimos general.useragent.override y en el valor  
escribimos “Nuevo navegador” y aceptamos:  

EN “DEBIAN SERVIDOR”, VOLVER A LANZAR nc  

Lanzamos “nc-lp 80” para ejecutar el programa.  

EN “UBUNTU”, CONECTAR A “http://10.x.y.1”  

Volvemos a conectar a la IP de Debian para generar una solicitud http.  

EN “DEBIAN SERVIDOR”, ¿ APARECE COMO  IDENTIFICADOR EL NUEVO NAVEGADOR ? 

![imagen](https://github.com/user-attachments/assets/a90a1838-6f53-4a6f-a801-8621313684ec)

# 6.3 
EN “UBUNTU”, EN EL NAVEGADOR EDITAR LAS PREFERENCIAS

En “Configuración”, dentro de la pestaña “Contenido”, seleccionamos “Idioma”.

AÑADIR CUALQUIER IDIOMA, COLOCARLO EL PRIMERO

Colocamos en primer lugar el idioma que queramos que sirva el servidor web.

EN “DEBIAN SERVIDOR”, LANZAR nc

Lanzamos “nc -lp 80”

EN “UBUNTU”, CONECTAR A “http://10.x.y.1”

En la línea “Accept-language” vemos que el primer código de idioma es el correspondiente al que hemos establecido en primer lugar en Firefox:

![imagen](https://github.com/user-attachments/assets/501d14ff-01f9-447d-b602-a00754a14a58)

# 6.5 6.6

✔ NOTA TEÓRICA:

Definición:

Cadena de caracteres que sirve para localizar de manera unívoca
recursos en internet.

Formato: protocolo://servidor:puerto/recurso#enlace

No es obligatorio utilizar todas las partes del formato, solamente las
que necesitemos en cada caso (el puerto y el enlace son opcionales).

.- En Debian Servidor lanzamos nc: nc -lp 8080

.- En Ubuntu Cliente en el navegador y escribimos:

http://IP:8080/pagina.html#enlace
- En Debian Servidor comprobamos que Ubuntu Cliente se ha conectado por el
puerto 8080 y que ha realizado la petición de la página:

➔ ¿Aparece el enlace? **SI**

![imagen](https://github.com/user-attachments/assets/a601384b-2eb2-487b-a99d-97d660052a51)

.- En Debian Servidor instalamos apache:
apt-get install apache2
.- Comprobamos que se ha instalado:
netstat -tlnp | grep 8
.- Comprobamos que responde a las peticiones
➔ Desde Ubuntu Cliente conectamos http://IP:

![imagen](https://github.com/user-attachments/assets/e624a1b4-5088-4157-a7e1-3daa66884098)

PRÁCTICA 6.7.- PÁGINAS SERVIDAS POR APACHE:

1.- En Debian servidor vamos al directorio /var/www/html. Comprobamos que existe un fichero llamado index.html: **EXISTE**

2.- Comprobamos que el contenido es el que recibimos desde Ubuntu Cliente (En la url no hemos especificado el nombre del fichero, Apache asume que el recurso es /):**Lo asume**

3.- En Debian Servidor en el directorio /var/www/html. Creamos un fichero llamado pagina1.html:

![imagen](https://github.com/user-attachments/assets/cdf76b04-88e4-4934-93df-e5b85262ded6)

4.- En Ubuntu Cliente lanzamos el navegador y escribimos http://IP/pagina1.html:

![imagen](https://github.com/user-attachments/assets/3f563f1e-53e3-46e5-8016-159eef7e8364)

5.- En Debian Servidor en el directorio /var/www/html Insertar una imagen (logo.png):

![imagen](https://github.com/user-attachments/assets/b7ab2856-5021-4144-b5ce-d88f0f28b15e)


6.- En Ubuntu Cliente lanzamos el navegador y escribimos http://IP/logo.png:

![imagen](https://github.com/user-attachments/assets/6097eaa6-16cc-4c6e-807a-2769413181bd)


7.- En Debian Servidor modificamos pagina.html para que muestre logo.png:

8.- En Ubuntu Cliente recargamos pagina1.html para ver el resultado:

![imagen](https://github.com/user-attachments/assets/7374579b-b6de-400a-b80a-2dc54d98ea6c)

9.-En Debian Servidor en pagina1.html, añadimos un enlace a pagina2.html:

![imagen](https://github.com/user-attachments/assets/812828f7-3788-44fc-baa7-dac33dc2d112)


10.- En Ubuntu Cliente recargamos pagina1.html e intentamos ir a pagina2.html:

![imagen](https://github.com/user-attachments/assets/88d71ed9-5963-4b2f-a4fe-b3c7711f115c)

11.- En Debian Servidor creamos pagina2.html con un enlace a pagina1.html:

12.- En Ubuntu Cliente recargamos pagina2.html e intentamos ir a pagina1.html:

# 6.8

✔ NOTA TEÓRICA: 
Hace referencia a cuando el navegador realiza una solicitud HTTP al servidor, este no cierra la conexión TCP con el cliente, que queda a la espera de nuevas solicitudes.  
Esto optimiza el uso de las conexiones TCP debido a que habitualmente un fichero html hace referencia a otros recursos que también se solicitan al servidor.  
Al mantener la conexión viva, estos recursos se consiguen a través de ella en lugar de exigir conexiones TCP adicionales ahorrando tráfico en la red.  
Este mecanismo deber soportarlo el Cliente y admitirlo el Servidor.  

1.- En Ubuntu Cliente vaciamos la cache del navegador:
2.- En Ubuntu Cliente lanzamos wireshark:
3.- En Ubuntu Cliente cargamos en el navegador pagina1.html:
4.- En Ubuntu Cliente vamos a wireshark y comprobamos que se ha creado una conexión y que esta no se ha cerrado:
(Vemos la conexión creada (http SYN) entre Ubuntu Cliente y Debian Servidor cuando hemos cargado página1.html)

![imagen](https://github.com/user-attachments/assets/5219a853-953e-4b4b-ba62-dbd4d7b41b19)

5.- En Ubuntu Cliente volvemos al navegador y pulsamos sobre el enlace a pagina2.html y en esta página sobre el enlace a pagina1.html, repetimos el proceso varias veces:
6.- En Ubuntu Cliente vamos a wireshark y comprobamos que no se han creado nuevas  conexiones. Esperamos unos instantes para que se cierre la conexión y verificamos en wireshark que se ha cerrado:

![imagen](https://github.com/user-attachments/assets/57053b15-bf6b-4fb3-befe-a439db16df5a)

7.- En Ubuntu Cliente anulamos Keep-Alive: 
En la barra de direcciones y escribimos about:config 
Buscamos la preferencia network.http.Keep-alive (si no la creamos)
Cambiarla a False


8.- En Debian Servidor lanzamos un servicio apache por el puerto 8080
nc -lp 8080
9.- En Ubuntu Cliente vamos al navegador en http://IP:8080:
➔ ¿Qué ocurre con la conexión? Que se cierra

10.- Volvemos a hacer las pruebas anteriores desde el punto 1 al 6
➔ En Ubuntu Cliente vaciamos la cache del navegador. Lanzamos wireshark. Cargamos en el navegador pagina1.html. Vamos a wireshark y comprobamos que se ha creado una conexión y lo que ocurre con ella:
✔ En este caso comprobamos que sí que se crea una nueva conexión (http SYN) cuando solicitamos del servidor el recurso pagina2.html y que además se cierra dicha conexión cuando se sirve dicho recurso.
➔ Volvemos a configurar preferencia network.http.Keep-alive a su valor por defecto.

![imagen](https://github.com/user-attachments/assets/3f6b6001-50b1-448e-a56e-a4c8beaf8c4e)

# PRÁCTICA 6.16.- CONFIGURACIÓN DE APACHE. User y Group:
✔ NOTA TEÓRICA:
En Apache hay varios procesos que se están ejecutando con un usuario diferente (www-data) y que son los que realmente contestan a los clientes (acceden a los  ficheros con recursos o ejecutan los cgi-bin). Las directivas que controlan que usuario del sistema se utiliza para servir a los clientes remotos son user y  group, indicando respectivamente el usuario y el grupo del sistema que ejecutará los procesos secundarios.  

1.- En Debian Servidor en el fichero de configuracion de Apache:  
➔ Buscamos las directivas anteriores y verificamos que se configuran como variables de entorno:  
	User ${APACHE_RUN_USER}  
	Group ${APACHE_RUN_GROUP}  

2.- Abrimos el fichero /etc/apache2/envvars:  
➔ ¿Qué valor se establece para esas directivas?:  
3.- Comprobamos que el usuario www-data existe en el sistema y no tiene contraseña:  
4.- Consultamos el fichero /etc/group:  
➔ ¿Existe un grupo www-data?:  
![imagen](https://github.com/user-attachments/assets/0724dbad-ad92-4a3a-bcc1-9b0048ef5243)

5.- Demostrar que los clientes son respondidos por esos usuarios:  
➔ Quitamos el permiso de ejecución para “otros” al fichero /usr/lib/cgi-bin/index.sh:  
![imagen](https://github.com/user-attachments/assets/6889e48c-022b-4cd0-b655-e8f1120189be)

6.- En Ubuntu Cliente accedemos a http://IP/cgi-bin/index.sh?/etc :  
➔ ¿Funciona? ¿Por qué?
**Porque no tiene permiso de ejecucion www-data sobre Index.sh**  
7.- Modificamos la posesión del fichero para que pertenezca a www-data:  
8.- Volvemos a acceder a http://IP/cgi-bin/index.sh?/etc :  
➔ ¿Funciona?  
**a2enmod cgi**
**El parametro se pasa con IP/cgi.bin/index.sh?etc**



# PRÁCTICA 6.17.- CONFIGURACIÓN DE APACHE. Include:
✔ NOTA TEÓRICA:  

La directiva Include sirve para incluir en un fichero adicional de configuración lo que nos interese en cada momento.  
Cuando Apache llegue a la línea del Include, se leerá el fichero que hemos creado y que está especificado detrás del Include, se analizarán sus directivas y   cuando termina vuelve a la línea posterior al Include dentro del fichero de configuración de Apache.  

1.- En Debian Servidor creamos el fichero /etc/apache2/mi.conf:  

➔ Añadimos las directivas de configuración de usuario y grupo:  
User ${APACHE_RUN_USER}  
Group ${APACHE_RUN_GROUP}  

2.- En el fichero de configuracion de Apach e, comentamos las dos líneas anteriores para que no las lea, e incluimos la siguiente linea:  

Include /etc/apache2/mi.conf  

3.- Reiniciamos Apache y comprobamos su estado:  

service apache2 restart  
service apache2 status  

4.- Desde Ubuntu Cliente comprobamos que sigue lanzado y que funciona  

http://IP/cgi-bin/index.sh?/etc :  

➔ Deshacemos los cambios del fichero de configuración de Apache y borramos el fichero /etc/apache2/mi.conf  

# PRÁCTICA 6.18.- CONFIGURACIÓN DE APACHE. Listen:

✔ NOTA TEÓRICA:  
El protocolo HTTP utiliza por defecto el puerto 80.  
Apache escucha en ese puerto debido a que la configuración predefinida de Debian así lo indica.  
Dicha configuración se mantiene dentro del archivo /etc/apache2/ports.conf  
1.- En Debian Servidor comprobamos que el fichero anterior está incluido en el  
fichero de configuracion de Apache:  

✔Hay una línea Include en apache2.conf en referencia a ports.conf  
✔Contenido de ports.conf:  
Formato de la directiva:  
Listen [IP:]puerto[protocolo]//  

2.- En Debian Servidor cambiamos la configuración para que Apache escuche por  
el puerto 8888 (además del 80 que ya tiene ):  

3.- Reiniciamos Apache y comprobamos que escucha por los dos puertos:  



4.- Desde Ubuntu Cliente comprobamos que podemos acceder por el puerto 8888  
 a http://IP/usr/cgi-bin/index.sh :  

![imagen](https://github.com/user-attachments/assets/99c265a1-1409-449b-bc15-e71ff8658964)

# PRÁCTICA 6.19.- CONFIGURACIÓN DE APACHE. ServerTokens:
✔ NOTA TEÓRICA:  
La directiva ServerTokens permite configurar cuanta información se envía del campo server en la respuesta.  
Sólo permite ajustarla, pero no modificarla.  
Para ello tiene los siguientes parámetros:  
✔ Prod ----- envía Apache  
✔ Major ----- envía Apache/2  
✔ Minor ----- envía Apache/2.2  
✔ Min ----- envía Apache/2.2.9  
✔ OS ----- envía Apache/2.2.9 (Debian)  
✔ Full ----- envía Apache/2.2.9 (Debian)  
Entre estos dos últimos hay diferencias si Apache tiene cargado algún módulo.  

1.- En Debian Servidor comprobamos el fichero /etc/apache2/conf-enabled/security.conf (Es donde se definen las directivas ServerTokens):  

2.- En Ubuntu Cliente lanzamos nc:  
nc IP 80  
GET / HTTP/1.1  
Host: IP  
...línea en blanco  
➔ Comprobamos la respuesta y nos fijamos en la línea Server:  
✔ Vemos que la respuesta es del tipo ServerTokens OS  
Server: Apache/2.4.10 (Debian)  
3.- En Debian Servidor cambiamos la directiva ServerTokens por otra:  
➔ Reiniciamos Apache  
4.- En Ubuntu Cliente lanzamos nc  para ver como ha cambiado la respuesta:  
**SOLO CAMBIA ESO NADA MAS**


